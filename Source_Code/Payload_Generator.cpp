    // This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.


#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <random>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <curl/curl.h>



using namespace std;



struct wd_in {
  size_t size;
  size_t len;
  char *data;
};


/* This function is registered as a callback with CURL.  As the data
   from the requested webpage is returned in chunks, write_data is
   called with each chunk.  */
static size_t write_data(void *buffer, size_t size, 
                         size_t nmemb, void *userp) {
  struct wd_in *wdi = (struct wd_in*)userp;

  while(wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->data = (char*)realloc(wdi->data, wdi->size*2);
    wdi->size*=2;
  }

  memcpy(wdi->data + wdi->len, buffer, size * nmemb);
  wdi->len+=size*nmemb;

  return size * nmemb;
}
string read(string URL)
{

CURL *curl;
  CURLcode res;
  struct wd_in wdi;
  //char *url = "http://www.google.com";

  memset(&wdi, 0, sizeof(wdi));

  /* Get a curl handle.  Each thread will need a unique handle. */
  curl = curl_easy_init();

  if(NULL != curl) {
    wdi.size = 1024;
    /* Check for malloc failure in real code. */
    wdi.data = (char*)malloc(wdi.size);

    /* Set the URL for the operation. */
    curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());

    /* "write_data" function to call with returned data. */
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

    /* userp parameter passed to write_data. */
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

    /* Actually perform the query. */
    res = curl_easy_perform(curl);

    /* Check the return value and do whatever. */

    /* Clean up after ourselves. */
    curl_easy_cleanup(curl);
  }
  else {
    fprintf(stderr, "Error: could not get CURL handle.\n");
    exit(EXIT_FAILURE);
  }

  /* Now wdi.data has the data from the GET and wdi.len is the length
     of the data available, so do whatever. */

  /* Write the content to stdout. */
  string data_f = string(wdi.data);

  /* cleanup wdi.data buffer. */
  free(wdi.data);

  return data_f;


}

int main(int argc, char **argv) {

  ifstream myReadFile;
  myReadFile.open("random_urls.txt");
  string data;
  int all_data_length=0;
  char output[100];
  multimap<int,string> finaldata;
  int i = 0;
  default_random_engine generator;
  binomial_distribution<int> distribution_b(124,0.75);
  binomial_distribution<int> distribution_bi(124,0.5);
  binomial_distribution<int> distribution_bi2(124,0.9);
  if (myReadFile.is_open()) {
	while (!myReadFile.eof()) 
		{
			myReadFile >> output;
			string dat = read(string(output));
			cout<<"inserting "<<i++<<endl;
			finaldata.insert(pair<int,string>(dat.length(),string(output)));
		}
	}
  myReadFile.close();
vector<string> URL_List;
multimap<int,string> :: iterator it = finaldata.begin();
while(it != finaldata.end())
{
	URL_List.push_back(it->second);
	it++;
}



{	
	ofstream myfile;
	myfile.open ("Payload1.txt");
	for(int i=0;i<1000;i++)
	{
	myfile<<URL_List[distribution_b(generator)]<<endl;
	}
	myfile.close();
}


{
	ofstream myfile;
  	myfile.open ("Payload2.txt");
	for(int i=0;i<100;i++)
	{
		int j=0;
		for(j=0;j<8;j++)
			myfile<<URL_List[distribution_bi(generator)]<<endl;
		for(j=8;j<10;j++)
			myfile<<URL_List[distribution_bi2(generator)]<<endl;
	}	
	myfile.close();
}




  return 0;
}

